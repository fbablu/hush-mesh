<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maritime ACPS - Multi-Route Planning</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0a0e1a; color: #fff; overflow: hidden; }
        
        .dashboard { display: grid; grid-template-columns: 280px 1fr 320px; height: 100vh; }
        
        .sidebar { background: rgba(255,255,255,0.05); padding: 1rem; border-right: 1px solid rgba(255,255,255,0.1); overflow-y: auto; }
        .sidebar h3 { color: #00ff88; margin-bottom: 1rem; font-size: 1rem; }
        
        .map-container { position: relative; background: #1a1a2e; overflow: hidden; }
        .map-canvas { width: 100%; height: 100%; background: linear-gradient(45deg, #16213e 0%, #0f3460 100%); position: relative; }
        
        .convoy { position: absolute; width: 20px; height: 20px; background: #00ff88; border-radius: 50%; 
                 box-shadow: 0 0 20px #00ff88; transition: all 0.3s ease; z-index: 10; }
        .convoy::after { content: 'üö¢'; position: absolute; top: -5px; left: -2px; font-size: 16px; }
        
        .threat { position: absolute; width: 15px; height: 15px; background: #ff4444; border-radius: 50%;
                 box-shadow: 0 0 15px #ff4444; z-index: 5; transition: all 0.3s ease; }
        
        .waypoint { position: absolute; width: 8px; height: 8px; background: #ffaa00; border-radius: 50%;
                   box-shadow: 0 0 10px #ffaa00; z-index: 3; }
        
        .destination { position: absolute; width: 15px; height: 15px; background: #ff6b6b; border-radius: 50%;
                      box-shadow: 0 0 15px #ff6b6b; z-index: 8; text-align: center; line-height: 15px; }
        
        /* Multiple path styles */
        .path-optimal { position: absolute; height: 3px; background: linear-gradient(90deg, #00ff88, #ffaa00);
                       box-shadow: 0 0 8px rgba(0,255,136,0.8); z-index: 4; transform-origin: left center; }
        .path-fastest { position: absolute; height: 2px; background: linear-gradient(90deg, #ff6b6b, #ffa500);
                       box-shadow: 0 0 6px rgba(255,107,107,0.6); z-index: 3; transform-origin: left center; opacity: 0.7; }
        .path-safest { position: absolute; height: 2px; background: linear-gradient(90deg, #4ecdc4, #45b7d1);
                      box-shadow: 0 0 6px rgba(78,205,196,0.6); z-index: 3; transform-origin: left center; opacity: 0.7; }
        
        .threat-zone { position: absolute; border: 2px dashed #ff4444; border-radius: 50%;
                      background: rgba(255,68,68,0.1); z-index: 1; transition: all 0.3s ease; }
        
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.3); } }
        @keyframes pathCalculation { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }
        
        .status-panel { background: rgba(0,0,0,0.3); padding: 0.8rem; margin-bottom: 0.8rem; border-radius: 6px; }
        .status-item { margin: 0.3rem 0; padding: 0.4rem; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 0.85rem; }
        
        .threat-alert { background: rgba(255,68,68,0.2); border-left: 4px solid #ff4444; }
        .safe-status { background: rgba(0,255,136,0.2); border-left: 4px solid #00ff88; }
        
        .route-option { background: rgba(255,255,255,0.08); border-radius: 6px; padding: 0.8rem; margin: 0.5rem 0; 
                       border-left: 4px solid #666; cursor: pointer; transition: all 0.3s ease; }
        .route-option:hover { background: rgba(255,255,255,0.12); }
        .route-option.selected { border-left-color: #00ff88; background: rgba(0,255,136,0.1); }
        .route-option.optimal { border-left-color: #00ff88; }
        .route-option.fastest { border-left-color: #ff6b6b; }
        .route-option.safest { border-left-color: #4ecdc4; }
        
        .route-metrics { font-size: 0.75rem; margin-top: 0.3rem; }
        .metric { display: inline-block; margin-right: 0.8rem; }
        
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); 
                   background: rgba(0,0,0,0.8); padding: 1rem; border-radius: 10px; }
        .btn { background: #2a5298; color: white; border: none; padding: 0.6rem 1.2rem; 
              border-radius: 5px; cursor: pointer; margin: 0 0.3rem; font-size: 0.85rem; }
        .btn:hover { background: #1e3c72; }
        .btn.danger { background: #ff4444; }
        .btn.success { background: #00ff88; color: #000; }
        
        .metrics { font-size: 0.8rem; }
        .metric-value { font-weight: bold; color: #00ff88; }
        
        .scenario-indicator { position: absolute; top: 15px; left: 15px; 
                            background: rgba(0,0,0,0.8); padding: 0.8rem; border-radius: 6px; }
        
        .calculation-status { position: absolute; top: 15px; right: 15px;
                            background: rgba(0,0,0,0.8); padding: 0.8rem; border-radius: 6px;
                            animation: pathCalculation 2s infinite; }
        
        .grid-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
                       background-image: 
                         linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                         linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
                       background-size: 40px 40px; z-index: 0; }
    </style>
</head>
<body>
    <div class="dashboard">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <h3>üõ°Ô∏è System Status</h3>
            <div class="status-panel">
                <div class="status-item safe-status" id="system-status">
                    <strong>System: OPERATIONAL</strong>
                </div>
                <div class="status-item" id="ml-status">
                    Multi-Route Planning: Active
                </div>
                <div class="status-item" id="drone-status">
                    Drones: 4/4 Online
                </div>
            </div>
            
            <h3>üìä Current Metrics</h3>
            <div class="status-panel metrics">
                <div>Position: <span class="metric-value" id="position">25.7617, -80.1918</span></div>
                <div>Speed: <span class="metric-value" id="speed">12 knots</span></div>
                <div>Heading: <span class="metric-value" id="heading">090¬∞</span></div>
                <div>Distance: <span class="metric-value" id="distance">8.2 km</span></div>
                <div>ETA: <span class="metric-value" id="eta">24 min</span></div>
            </div>
            
            <h3>üö® Active Threats</h3>
            <div class="status-panel" id="threat-panel">
                <div class="status-item safe-status">
                    No threats detected
                </div>
            </div>
        </div>
        
        <!-- Main Map -->
        <div class="map-container">
            <div class="scenario-indicator">
                <h4 id="scenario-title">Multi-Route Planning</h4>
                <p id="scenario-desc">Calculating optimal paths...</p>
            </div>
            
            <div class="calculation-status" id="calc-status" style="display: none;">
                üß† Analyzing Routes...
            </div>
            
            <div class="map-canvas" id="map">
                <div class="grid-overlay"></div>
            </div>
        </div>
        
        <!-- Right Sidebar -->
        <div class="sidebar">
            <h3>üó∫Ô∏è Route Options</h3>
            <div id="route-options">
                <div class="route-option optimal selected" data-route="optimal">
                    <strong>üéØ Optimal Route</strong>
                    <div class="route-metrics">
                        <span class="metric">Distance: <span id="optimal-distance">--</span></span>
                        <span class="metric">Risk: <span id="optimal-risk">--</span></span>
                        <span class="metric">Score: <span id="optimal-score">--</span></span>
                    </div>
                </div>
                
                <div class="route-option fastest" data-route="fastest">
                    <strong>‚ö° Fastest Route</strong>
                    <div class="route-metrics">
                        <span class="metric">Distance: <span id="fastest-distance">--</span></span>
                        <span class="metric">Risk: <span id="fastest-risk">--</span></span>
                        <span class="metric">Score: <span id="fastest-score">--</span></span>
                    </div>
                </div>
                
                <div class="route-option safest" data-route="safest">
                    <strong>üõ°Ô∏è Safest Route</strong>
                    <div class="route-metrics">
                        <span class="metric">Distance: <span id="safest-distance">--</span></span>
                        <span class="metric">Risk: <span id="safest-risk">--</span></span>
                        <span class="metric">Score: <span id="safest-score">--</span></span>
                    </div>
                </div>
            </div>
            
            <h3>üì° Path Analysis</h3>
            <div class="status-panel">
                <div class="status-item" id="path-analysis">
                    Calculating multiple routes...
                </div>
                <div class="status-item" id="threat-consideration">
                    Threat assessment: Pending
                </div>
                <div class="status-item" id="route-recommendation">
                    Recommendation: Analyzing...
                </div>
            </div>
            
            <h3>üéØ Mission Log</h3>
            <div class="status-panel" id="mission-log" style="height: 150px; overflow-y: auto; font-size: 0.75rem;">
                <div>[00:00] Multi-route planning initialized</div>
                <div>[00:00] Analyzing threat landscape</div>
                <div>[00:00] Calculating path alternatives</div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn success" onclick="startDemo()">‚ñ∂Ô∏è Start Demo</button>
        <button class="btn" onclick="pauseDemo()">‚è∏Ô∏è Pause</button>
        <button class="btn danger" onclick="stopDemo()">‚èπÔ∏è Stop</button>
        <button class="btn" onclick="resetDemo()">üîÑ Reset</button>
        <button class="btn" onclick="recalculateRoutes()">üß† Recalculate</button>
    </div>

    <script>
        console.log('Loading Multi-Route Maritime Dashboard');
        
        class MultiRouteMaritimeDashboard {
            constructor() {
                console.log('Initializing dashboard...');
                this.convoy = { x: 100, y: 400, lat: 25.7617, lon: -80.1918 };
                this.destination = { x: 700, y: 200, lat: 25.8200, lon: -80.1200 };
                this.running = false;
                this.speed = 1;
                this.step = 0;
                this.selectedRoute = 'optimal';
                
                this.syntheticThreats = [
                    { x: 300, y: 450, vx: -1, vy: -2, type: 'small_fast_craft', radius: 60, name: 'Pirate Skiff', speed: 2.5, behavior: 'intercept' },
                    { x: 500, y: 150, vx: 0, vy: 1, type: 'floating_mine_like_object', radius: 40, name: 'Drifting Mine', speed: 0.8, behavior: 'drift' },
                    { x: 650, y: 350, vx: -1.5, vy: 0.5, type: 'submarine_periscope', radius: 80, name: 'Sub Contact', speed: 1.2, behavior: 'patrol' },
                    { x: 150, y: 100, vx: 2, vy: 1, type: 'debris_field', radius: 90, name: 'Debris Field', speed: 0.5, behavior: 'expand' }
                ];
                
                this.routes = {};
                this.detectedThreats = new Set();
                this.threatMovementPatterns = new Map();
                this.calculationInProgress = false;
                
                this.initializeMap();
                this.drawSyntheticThreats();
                this.setupRouteSelection();
                setTimeout(() => this.calculateMultipleRoutes(), 500);
            }
            
            initializeMap() {
                console.log('Initializing map...');
                const map = document.getElementById('map');
                
                // Add convoy ship
                const convoy = document.createElement('div');
                convoy.className = 'convoy';
                convoy.id = 'convoy';
                convoy.style.left = this.convoy.x + 'px';
                convoy.style.top = this.convoy.y + 'px';
                convoy.style.position = 'absolute';
                convoy.style.zIndex = '10';
                map.appendChild(convoy);
                console.log('Convoy added at:', this.convoy.x, this.convoy.y);
                
                // Add destination target
                const dest = document.createElement('div');
                dest.className = 'destination';
                dest.id = 'destination';
                dest.style.left = this.destination.x + 'px';
                dest.style.top = this.destination.y + 'px';
                dest.style.position = 'absolute';
                dest.style.zIndex = '8';
                dest.innerHTML = 'üéØ';
                dest.style.fontSize = '12px';
                dest.style.textAlign = 'center';
                dest.style.lineHeight = '15px';
                map.appendChild(dest);
                console.log('Destination added at:', this.destination.x, this.destination.y);
            }
            
            drawSyntheticThreats() {
                const map = document.getElementById('map');
                
                this.syntheticThreats.forEach((threat, i) => {
                    const threatEl = document.createElement('div');
                    threatEl.className = 'threat';
                    threatEl.id = `synthetic-threat-${i}`;
                    threatEl.style.left = threat.x + 'px';
                    threatEl.style.top = threat.y + 'px';
                    threatEl.style.display = 'none';
                    threatEl.style.position = 'absolute';
                    threatEl.title = threat.name;
                    
                    if (threat.behavior === 'intercept') threatEl.innerHTML = 'üö§';
                    else if (threat.behavior === 'drift') threatEl.innerHTML = 'üí£';
                    else if (threat.behavior === 'patrol') threatEl.innerHTML = 'üî≠';
                    else if (threat.behavior === 'expand') threatEl.innerHTML = 'üóëÔ∏è';
                    
                    map.appendChild(threatEl);
                    
                    const zone = document.createElement('div');
                    zone.className = 'threat-zone';
                    zone.id = `threat-zone-${i}`;
                    zone.style.left = (threat.x - threat.radius) + 'px';
                    zone.style.top = (threat.y - threat.radius) + 'px';
                    zone.style.width = (threat.radius * 2) + 'px';
                    zone.style.height = (threat.radius * 2) + 'px';
                    zone.style.display = 'none';
                    zone.style.position = 'absolute';
                    map.appendChild(zone);
                    
                    this.initializeThreatMovement(threat, i);
                });
            }
            
            initializeThreatMovement(threat, index) {
                this.threatMovementPatterns.set(index, {
                    originalX: threat.x,
                    originalY: threat.y,
                    patrolTime: 0
                });
            }
            
            setupRouteSelection() {
                document.querySelectorAll('.route-option').forEach(option => {
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.route-option').forEach(o => o.classList.remove('selected'));
                        option.classList.add('selected');
                        this.selectedRoute = option.dataset.route;
                        this.updateActiveRoute();
                        this.logMessage(`üìç Switched to ${option.dataset.route} route`);
                    });
                });
            }
            
            calculateMultipleRoutes() {
                this.calculationInProgress = true;
                document.getElementById('calc-status').style.display = 'block';
                
                setTimeout(() => {
                    this.routes = {
                        optimal: this.generateRoute('optimal'),
                        fastest: this.generateRoute('fastest'),
                        safest: this.generateRoute('safest')
                    };
                    
                    this.drawAllRoutes();
                    this.updateRouteMetrics();
                    this.updateActiveRoute();
                    this.analyzeRoutes();
                    
                    this.calculationInProgress = false;
                    document.getElementById('calc-status').style.display = 'none';
                    
                    this.logMessage('üß† Multiple routes calculated successfully');
                }, 2000);
            }
            
            generateRoute(strategy) {
                const waypoints = [];
                const steps = 8;
                
                for (let i = 1; i <= steps; i++) {
                    const progress = i / steps;
                    let x = this.convoy.x + (this.destination.x - this.convoy.x) * progress;
                    let y = this.convoy.y + (this.destination.y - this.convoy.y) * progress;
                    
                    if (strategy === 'fastest') {
                        // Direct route
                    } else if (strategy === 'safest') {
                        y -= 60 * Math.sin(progress * Math.PI);
                        x += 20 * Math.cos(progress * Math.PI * 2);
                    } else {
                        // Optimal: avoid threats
                        this.syntheticThreats.forEach(threat => {
                            const distance = Math.sqrt((x - threat.x)**2 + (y - threat.y)**2);
                            if (distance < threat.radius + 30) {
                                const avoidX = (x - threat.x) / distance * (threat.radius + 30);
                                const avoidY = (y - threat.y) / distance * (threat.radius + 30);
                                x = threat.x + avoidX;
                                y = threat.y + avoidY;
                            }
                        });
                    }
                    
                    waypoints.push({ x, y });
                }
                
                const distance = this.calculateRouteDistance(waypoints);
                const threatExposure = this.calculateThreatExposure(waypoints);
                const score = this.calculateRouteScore(distance, threatExposure, strategy);
                
                return {
                    waypoints,
                    metrics: {
                        distance: distance.toFixed(1),
                        threatExposure: threatExposure.toFixed(1),
                        score: score.toFixed(0)
                    }
                };
            }
            
            calculateRouteDistance(waypoints) {
                let distance = 0;
                let prev = this.convoy;
                waypoints.forEach(wp => {
                    distance += Math.sqrt((wp.x - prev.x)**2 + (wp.y - prev.y)**2);
                    prev = wp;
                });
                return distance * 0.01;
            }
            
            calculateThreatExposure(waypoints) {
                let exposure = 0;
                waypoints.forEach(wp => {
                    this.syntheticThreats.forEach(threat => {
                        const distance = Math.sqrt((wp.x - threat.x)**2 + (wp.y - threat.y)**2);
                        if (distance < threat.radius * 1.5) {
                            exposure += (threat.radius * 1.5 - distance) / threat.radius;
                        }
                    });
                });
                return exposure;
            }
            
            calculateRouteScore(distance, threatExposure, strategy) {
                if (strategy === 'fastest') {
                    return 100 - distance * 3 - threatExposure * 1;
                } else if (strategy === 'safest') {
                    return 100 - threatExposure * 8 - distance * 0.5;
                } else {
                    return 100 - distance * 2 - threatExposure * 3;
                }
            }
            
            drawAllRoutes() {
                document.querySelectorAll('.path-optimal, .path-fastest, .path-safest').forEach(el => el.remove());
                
                Object.keys(this.routes).forEach(strategy => {
                    this.drawRoute(strategy, this.routes[strategy].waypoints);
                });
            }
            
            drawRoute(strategy, waypoints) {
                const map = document.getElementById('map');
                let prevPoint = this.convoy;
                
                waypoints.forEach(wp => {
                    const line = document.createElement('div');
                    line.className = `path-${strategy}`;
                    line.style.position = 'absolute';
                    
                    const dx = wp.x - prevPoint.x;
                    const dy = wp.y - prevPoint.y;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    line.style.left = prevPoint.x + 'px';
                    line.style.top = prevPoint.y + 'px';
                    line.style.width = length + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    
                    map.appendChild(line);
                    prevPoint = wp;
                });
            }
            
            updateRouteMetrics() {
                Object.keys(this.routes).forEach(strategy => {
                    const metrics = this.routes[strategy].metrics;
                    document.getElementById(`${strategy}-distance`).textContent = `${metrics.distance}km`;
                    document.getElementById(`${strategy}-risk`).textContent = metrics.threatExposure;
                    document.getElementById(`${strategy}-score`).textContent = metrics.score;
                });
            }
            
            updateActiveRoute() {
                document.querySelectorAll('.path-optimal, .path-fastest, .path-safest').forEach(el => {
                    el.style.opacity = '0.3';
                });
                
                document.querySelectorAll(`.path-${this.selectedRoute}`).forEach(el => {
                    el.style.opacity = '1';
                    el.style.zIndex = '5';
                });
            }
            
            analyzeRoutes() {
                const routes = this.routes;
                const fastest = Object.keys(routes).reduce((a, b) => 
                    parseFloat(routes[a].metrics.distance) < parseFloat(routes[b].metrics.distance) ? a : b);
                const safest = Object.keys(routes).reduce((a, b) => 
                    parseFloat(routes[a].metrics.threatExposure) < parseFloat(routes[b].metrics.threatExposure) ? a : b);
                const highest_score = Object.keys(routes).reduce((a, b) => 
                    parseFloat(routes[a].metrics.score) > parseFloat(routes[b].metrics.score) ? a : b);
                
                const analysis = `Fastest: ${fastest} | Safest: ${safest} | Best Score: ${highest_score}`;
                
                const threatCount = this.detectedThreats.size;
                let recommendation;
                if (threatCount === 0) {
                    recommendation = 'Low threat environment - Fastest route recommended';
                } else if (threatCount >= 3) {
                    recommendation = 'High threat environment - Safest route recommended';
                } else {
                    recommendation = 'Moderate threats - Optimal route recommended';
                }
                
                document.getElementById('path-analysis').textContent = analysis;
                document.getElementById('route-recommendation').textContent = recommendation;
            }
            
            detectNearbyThreats() {
                this.syntheticThreats.forEach((threat, i) => {
                    const distance = Math.sqrt((this.convoy.x - threat.x)**2 + (this.convoy.y - threat.y)**2);
                    
                    if (distance < threat.radius * 1.3) {
                        if (!this.detectedThreats.has(i)) {
                            this.logMessage(`üö® Threat detected: ${threat.name}`);
                        }
                        document.getElementById(`synthetic-threat-${i}`).style.display = 'block';
                        document.getElementById(`threat-zone-${i}`).style.display = 'block';
                        this.detectedThreats.add(i);
                    } else if (distance > threat.radius * 2) {
                        document.getElementById(`synthetic-threat-${i}`).style.display = 'none';
                        document.getElementById(`threat-zone-${i}`).style.display = 'none';
                        this.detectedThreats.delete(i);
                    }
                });
                
                this.updateThreatPanel();
            }
            
            updateThreatPanel() {
                const panel = document.getElementById('threat-panel');
                panel.innerHTML = '';
                
                if (this.detectedThreats.size === 0) {
                    panel.innerHTML = '<div class="status-item safe-status">No threats in detection range</div>';
                } else {
                    this.detectedThreats.forEach(threatIndex => {
                        const threat = this.syntheticThreats[threatIndex];
                        const distance = Math.sqrt((this.convoy.x - threat.x)**2 + (this.convoy.y - threat.y)**2);
                        
                        const item = document.createElement('div');
                        item.className = 'status-item threat-alert';
                        item.innerHTML = `
                            <strong>${threat.name}</strong><br>
                            Distance: ${Math.floor(distance * 10)}m | Behavior: ${threat.behavior}
                        `;
                        panel.appendChild(item);
                    });
                }
            }
            
            moveConvoy() {
                if (!this.routes[this.selectedRoute]) return;
                
                const waypoints = this.routes[this.selectedRoute].waypoints;
                if (waypoints.length === 0) return;
                
                const target = waypoints[0];
                const dx = target.x - this.convoy.x;
                const dy = target.y - this.convoy.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 15) {
                    waypoints.shift();
                    if (waypoints.length === 0) {
                        this.logMessage('üèÅ Destination reached!');
                        this.stop();
                        return;
                    }
                } else {
                    const speed = 3 * this.speed;
                    this.convoy.x += (dx / distance) * speed;
                    this.convoy.y += (dy / distance) * speed;
                }
                
                document.getElementById('convoy').style.left = this.convoy.x + 'px';
                document.getElementById('convoy').style.top = this.convoy.y + 'px';
                
                this.updateMetrics();
            }
            
            updateMetrics() {
                const distToDest = Math.sqrt((this.destination.x - this.convoy.x)**2 + (this.destination.y - this.convoy.y)**2) * 0.01;
                
                document.getElementById('position').textContent = 
                    `${(this.convoy.lat + Math.random() * 0.001).toFixed(4)}, ${(this.convoy.lon + Math.random() * 0.001).toFixed(4)}`;
                document.getElementById('distance').textContent = `${distToDest.toFixed(1)} km`;
                document.getElementById('eta').textContent = `${Math.floor(distToDest * 2)} min`;
                
                document.getElementById('scenario-desc').textContent = 
                    `Following ${this.selectedRoute} route | ${this.detectedThreats.size} threats active`;
            }
            
            logMessage(message) {
                const log = document.getElementById('mission-log');
                const time = new Date().toLocaleTimeString().slice(0, 5);
                const div = document.createElement('div');
                div.textContent = `[${time}] ${message}`;
                log.insertBefore(div, log.firstChild);
                
                while (log.children.length > 8) {
                    log.removeChild(log.lastChild);
                }
            }
            
            start() {
                if (this.running) return;
                this.running = true;
                this.logMessage('üö¢ Multi-route demo started');
                this.animate();
            }
            
            pause() {
                this.running = false;
                this.logMessage('‚è∏Ô∏è Demo paused');
            }
            
            stop() {
                this.running = false;
                this.logMessage('‚èπÔ∏è Demo stopped');
            }
            
            reset() {
                this.running = false;
                this.step = 0;
                this.convoy = { x: 100, y: 400, lat: 25.7617, lon: -80.1918 };
                this.detectedThreats.clear();
                
                // Clear and reinitialize
                const map = document.getElementById('map');
                map.innerHTML = '<div class="grid-overlay"></div>';
                
                this.initializeMap();
                this.drawSyntheticThreats();
                this.calculateMultipleRoutes();
                this.updateThreatPanel();
                this.logMessage('üîÑ Demo reset - Recalculating routes');
            }
            
            recalculateRoutes() {
                this.logMessage('üß† Recalculating routes due to threat movement');
                this.calculateMultipleRoutes();
            }
            
            animate() {
                if (!this.running) return;
                
                this.step++;
                this.detectNearbyThreats();
                this.moveConvoy();
                
                if (this.step % 10 === 0 && !this.calculationInProgress) {
                    this.recalculateRoutes();
                }
                
                setTimeout(() => this.animate(), 1000 / this.speed);
            }
        }
        
        let dashboard;
        
        function startDemo() { dashboard.start(); }
        function pauseDemo() { dashboard.pause(); }
        function stopDemo() { dashboard.stop(); }
        function resetDemo() { dashboard.reset(); }
        function recalculateRoutes() { dashboard.recalculateRoutes(); }
        
        window.onload = () => {
            dashboard = new MultiRouteMaritimeDashboard();
            console.log('Dashboard loaded successfully');
        };
    </script>
</body>
</html>