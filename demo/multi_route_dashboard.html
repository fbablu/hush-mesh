<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maritime ACPS - Multi-Route Planning</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0a0e1a; color: #fff; overflow: hidden; }
        
        .dashboard { display: grid; grid-template-columns: 280px 1fr 320px; height: 100vh; }
        
        .sidebar { background: rgba(255,255,255,0.05); padding: 1rem; border-right: 1px solid rgba(255,255,255,0.1); overflow-y: auto; }
        .sidebar h3 { color: #00ff88; margin-bottom: 1rem; font-size: 1rem; }
        
        .map-container { position: relative; background: #1a1a2e; overflow: hidden; }
        .map-canvas { width: 100%; height: 100%; background: linear-gradient(45deg, #16213e 0%, #0f3460 100%); position: relative; }
        
        .convoy { position: absolute; width: 20px; height: 20px; background: #00ff88; border-radius: 50%; 
                 box-shadow: 0 0 20px #00ff88; transition: all 0.3s ease; z-index: 10; }
        .convoy::after { content: 'üö¢'; position: absolute; top: -5px; left: -2px; font-size: 16px; }
        
        .threat { position: absolute; width: 15px; height: 15px; background: #ff4444; border-radius: 50%;
                 box-shadow: 0 0 15px #ff4444; z-index: 5; transition: all 0.3s ease; }
        
        .waypoint { position: absolute; width: 8px; height: 8px; background: #ffaa00; border-radius: 50%;
                   box-shadow: 0 0 10px #ffaa00; z-index: 3; }
        
        /* Multiple path styles */
        .path-optimal { position: absolute; height: 3px; background: linear-gradient(90deg, #00ff88, #ffaa00);
                       box-shadow: 0 0 8px rgba(0,255,136,0.8); z-index: 4; transform-origin: left center; }
        .path-fastest { position: absolute; height: 2px; background: linear-gradient(90deg, #ff6b6b, #ffa500);
                       box-shadow: 0 0 6px rgba(255,107,107,0.6); z-index: 3; transform-origin: left center; opacity: 0.7; }
        .path-safest { position: absolute; height: 2px; background: linear-gradient(90deg, #4ecdc4, #45b7d1);
                      box-shadow: 0 0 6px rgba(78,205,196,0.6); z-index: 3; transform-origin: left center; opacity: 0.7; }
        
        .threat-zone { position: absolute; border: 2px dashed #ff4444; border-radius: 50%;
                      background: rgba(255,68,68,0.1); z-index: 1; transition: all 0.3s ease; }
        
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.3); } }
        @keyframes pathCalculation { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }
        
        .status-panel { background: rgba(0,0,0,0.3); padding: 0.8rem; margin-bottom: 0.8rem; border-radius: 6px; }
        .status-item { margin: 0.3rem 0; padding: 0.4rem; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 0.85rem; }
        
        .threat-alert { background: rgba(255,68,68,0.2); border-left: 4px solid #ff4444; }
        .safe-status { background: rgba(0,255,136,0.2); border-left: 4px solid #00ff88; }
        
        .route-option { background: rgba(255,255,255,0.08); border-radius: 6px; padding: 0.8rem; margin: 0.5rem 0; 
                       border-left: 4px solid #666; cursor: pointer; transition: all 0.3s ease; }
        .route-option:hover { background: rgba(255,255,255,0.12); }
        .route-option.selected { border-left-color: #00ff88; background: rgba(0,255,136,0.1); }
        .route-option.optimal { border-left-color: #00ff88; }
        .route-option.fastest { border-left-color: #ff6b6b; }
        .route-option.safest { border-left-color: #4ecdc4; }
        
        .route-metrics { font-size: 0.75rem; margin-top: 0.3rem; }
        .metric { display: inline-block; margin-right: 0.8rem; }
        
        .controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); 
                   background: rgba(0,0,0,0.8); padding: 1rem; border-radius: 10px; }
        .btn { background: #2a5298; color: white; border: none; padding: 0.6rem 1.2rem; 
              border-radius: 5px; cursor: pointer; margin: 0 0.3rem; font-size: 0.85rem; }
        .btn:hover { background: #1e3c72; }
        .btn.danger { background: #ff4444; }
        .btn.success { background: #00ff88; color: #000; }
        
        .metrics { font-size: 0.8rem; }
        .metric-value { font-weight: bold; color: #00ff88; }
        
        .scenario-indicator { position: absolute; top: 15px; left: 15px; 
                            background: rgba(0,0,0,0.8); padding: 0.8rem; border-radius: 6px; }
        
        .calculation-status { position: absolute; top: 15px; right: 15px;
                            background: rgba(0,0,0,0.8); padding: 0.8rem; border-radius: 6px;
                            animation: pathCalculation 2s infinite; }
        
        .grid-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
                       background-image: 
                         linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                         linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
                       background-size: 40px 40px; z-index: 0; }
    </style>
</head>
<body>
    <div class="dashboard">
        <!-- Left Sidebar -->
        <div class="sidebar">
            <h3>üõ°Ô∏è System Status</h3>
            <div class="status-panel">
                <div class="status-item safe-status" id="system-status">
                    <strong>System: OPERATIONAL</strong>
                </div>
                <div class="status-item" id="ml-status">
                    ML Model: Active (92.86% accuracy)
                </div>
                <div class="status-item" id="drone-status">
                    Drones: 4/4 Online
                </div>
            </div>
            
            <h3>üìä Current Metrics</h3>
            <div class="status-panel metrics">
                <div>Position: <span class="metric-value" id="position">25.7617, -80.1918</span></div>
                <div>Speed: <span class="metric-value" id="speed">12 knots</span></div>
                <div>Heading: <span class="metric-value" id="heading">090¬∞</span></div>
                <div>Distance: <span class="metric-value" id="distance">8.2 km</span></div>
                <div>ETA: <span class="metric-value" id="eta">24 min</span></div>
            </div>
            
            <h3>üö® Active Threats</h3>
            <div class="status-panel" id="threat-panel">
                <div class="status-item safe-status">
                    No threats detected
                </div>
            </div>
        </div>
        
        <!-- Main Map -->
        <div class="map-container">
            <div class="scenario-indicator">
                <h4 id="scenario-title">Multi-Route Planning</h4>
                <p id="scenario-desc">Calculating optimal paths...</p>
            </div>
            
            <div class="calculation-status" id="calc-status" style="display: none;">
                üß† Analyzing Routes...
            </div>
            
            <div class="map-canvas" id="map">
                <div class="grid-overlay"></div>
            </div>
        </div>
        
        <!-- Right Sidebar -->
        <div class="sidebar">
            <h3>üó∫Ô∏è Route Options</h3>
            <div id="route-options">
                <div class="route-option optimal selected" data-route="optimal">
                    <strong>üéØ Optimal Route</strong>
                    <div class="route-metrics">
                        <span class="metric">Distance: <span id="optimal-distance">--</span></span>
                        <span class="metric">Risk: <span id="optimal-risk">--</span></span>
                        <span class="metric">Score: <span id="optimal-score">--</span></span>
                    </div>
                </div>
                
                <div class="route-option fastest" data-route="fastest">
                    <strong>‚ö° Fastest Route</strong>
                    <div class="route-metrics">
                        <span class="metric">Distance: <span id="fastest-distance">--</span></span>
                        <span class="metric">Risk: <span id="fastest-risk">--</span></span>
                        <span class="metric">Score: <span id="fastest-score">--</span></span>
                    </div>
                </div>
                
                <div class="route-option safest" data-route="safest">
                    <strong>üõ°Ô∏è Safest Route</strong>
                    <div class="route-metrics">
                        <span class="metric">Distance: <span id="safest-distance">--</span></span>
                        <span class="metric">Risk: <span id="safest-risk">--</span></span>
                        <span class="metric">Score: <span id="safest-score">--</span></span>
                    </div>
                </div>
            </div>
            
            <h3>üì° Path Analysis</h3>
            <div class="status-panel">
                <div class="status-item" id="path-analysis">
                    Calculating multiple routes...
                </div>
                <div class="status-item" id="threat-consideration">
                    Threat assessment: Pending
                </div>
                <div class="status-item" id="route-recommendation">
                    Recommendation: Analyzing...
                </div>
            </div>
            
            <h3>üéØ Mission Log</h3>
            <div class="status-panel" id="mission-log" style="height: 150px; overflow-y: auto; font-size: 0.75rem;">
                <div>[00:00] Multi-route planning initialized</div>
                <div>[00:00] Analyzing threat landscape</div>
                <div>[00:00] Calculating path alternatives</div>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn success" onclick="startDemo()">‚ñ∂Ô∏è Start Demo</button>
        <button class="btn" onclick="pauseDemo()">‚è∏Ô∏è Pause</button>
        <button class="btn danger" onclick="stopDemo()">‚èπÔ∏è Stop</button>
        <button class="btn" onclick="resetDemo()">üîÑ Reset</button>
        <button class="btn" onclick="recalculateRoutes()">üß† Recalculate</button>
    </div>

    <script>
        class MultiRouteMaritimeDashboard {
            constructor() {
                this.convoy = { x: 100, y: 400, lat: 25.7617, lon: -80.1918 };
                this.destination = { x: 700, y: 200, lat: 25.8200, lon: -80.1200 };
                this.running = false;
                this.speed = 1;
                this.step = 0;
                this.selectedRoute = 'optimal';
                
                this.syntheticThreats = [
                    { x: 300, y: 450, vx: -1, vy: -2, type: 'small_fast_craft', radius: 60, name: 'Pirate Skiff', speed: 2.5, behavior: 'intercept' },
                    { x: 500, y: 150, vx: 0, vy: 1, type: 'floating_mine_like_object', radius: 40, name: 'Drifting Mine', speed: 0.8, behavior: 'drift' },
                    { x: 650, y: 350, vx: -1.5, vy: 0.5, type: 'submarine_periscope', radius: 80, name: 'Sub Contact', speed: 1.2, behavior: 'patrol' },
                    { x: 150, y: 100, vx: 2, vy: 1, type: 'debris_field', radius: 90, name: 'Debris Field', speed: 0.5, behavior: 'expand' }
                ];
                
                this.routes = {};
                this.detectedThreats = new Set();
                this.threatMovementPatterns = new Map();
                this.calculationInProgress = false;
                
                this.initializeMap();
                this.drawSyntheticThreats();
                this.setupRouteSelection();
                this.calculateMultipleRoutes();
            }
            
            initializeMap() {
                const map = document.getElementById('map');
                
                const convoy = document.createElement('div');
                convoy.className = 'convoy';
                convoy.id = 'convoy';
                convoy.style.left = this.convoy.x + 'px';
                convoy.style.top = this.convoy.y + 'px';
                map.appendChild(convoy);
                
                const dest = document.createElement('div');
                dest.className = 'waypoint';
                dest.style.left = this.destination.x + 'px';
                dest.style.top = this.destination.y + 'px';
                dest.style.background = '#ff6b6b';
                dest.style.width = '15px';
                dest.style.height = '15px';
                dest.innerHTML = 'üéØ';
                dest.style.fontSize = '12px';
                map.appendChild(dest);
            }
            
            drawSyntheticThreats() {
                const map = document.getElementById('map');
                
                this.syntheticThreats.forEach((threat, i) => {
                    const threatEl = document.createElement('div');
                    threatEl.className = 'threat';
                    threatEl.id = `synthetic-threat-${i}`;
                    threatEl.style.left = threat.x + 'px';
                    threatEl.style.top = threat.y + 'px';
                    threatEl.style.display = 'none';
                    threatEl.title = threat.name;
                    
                    if (threat.behavior === 'intercept') threatEl.innerHTML = 'üö§';
                    else if (threat.behavior === 'drift') threatEl.innerHTML = 'üí£';
                    else if (threat.behavior === 'patrol') threatEl.innerHTML = 'üî≠';
                    else if (threat.behavior === 'expand') threatEl.innerHTML = 'üóëÔ∏è';
                    
                    map.appendChild(threatEl);
                    
                    const zone = document.createElement('div');
                    zone.className = 'threat-zone';
                    zone.id = `threat-zone-${i}`;
                    zone.style.left = (threat.x - threat.radius) + 'px';
                    zone.style.top = (threat.y - threat.radius) + 'px';
                    zone.style.width = (threat.radius * 2) + 'px';
                    zone.style.height = (threat.radius * 2) + 'px';
                    zone.style.display = 'none';
                    map.appendChild(zone);
                    
                    this.initializeThreatMovement(threat, i);
                });
            }
            
            initializeThreatMovement(threat, index) {
                this.threatMovementPatterns.set(index, {
                    originalX: threat.x,
                    originalY: threat.y,
                    patrolTime: 0
                });
            }
            
            setupRouteSelection() {
                document.querySelectorAll('.route-option').forEach(option => {
                    option.addEventListener('click', () => {
                        document.querySelectorAll('.route-option').forEach(o => o.classList.remove('selected'));
                        option.classList.add('selected');
                        this.selectedRoute = option.dataset.route;
                        this.updateActiveRoute();
                        this.logMessage(`üìç Switched to ${option.dataset.route} route`);
                    });
                });
            }
            
            calculateMultipleRoutes() {
                this.calculationInProgress = true;
                document.getElementById('calc-status').style.display = 'block';
                
                // Simulate route calculation with visual feedback
                setTimeout(() => {
                    this.routes = {
                        optimal: this.generateRoute('optimal'),
                        fastest: this.generateRoute('fastest'),
                        safest: this.generateRoute('safest')
                    };
                    
                    this.drawAllRoutes();
                    this.updateRouteMetrics();
                    this.updateActiveRoute();
                    this.analyzeRoutes();
                    
                    this.calculationInProgress = false;
                    document.getElementById('calc-status').style.display = 'none';
                    
                    this.logMessage('üß† Multiple routes calculated successfully');
                }, 2000);
            }
            
            generateRoute(strategy) {
                const waypoints = [];
                const steps = 8;
                
                for (let i = 1; i <= steps; i++) {
                    const progress = i / steps;
                    let x = this.convoy.x + (this.destination.x - this.convoy.x) * progress;
                    let y = this.convoy.y + (this.destination.y - this.convoy.y) * progress;
                    
                    // Apply strategy-specific modifications
                    if (strategy === 'fastest') {
                        // More direct route, less threat avoidance
                        const directFactor = 0.8;
                        x = this.convoy.x + (this.destination.x - this.convoy.x) * progress * directFactor + 
                            (this.destination.x - this.convoy.x) * (1 - directFactor) * progress;
                    } else if (strategy === 'safest') {
                        // Wide berth around threats
                        y -= 60 * Math.sin(progress * Math.PI); // Arc around threats
                        x += 20 * Math.cos(progress * Math.PI * 2); // Zigzag pattern
                    } else {
                        // Optimal: balanced approach
                        this.syntheticThreats.forEach(threat => {
                            const distance = Math.sqrt((x - threat.x)**2 + (y - threat.y)**2);
                            if (distance < threat.radius + 30) {
                                const avoidX = (x - threat.x) / distance * (threat.radius + 30);
                                const avoidY = (y - threat.y) / distance * (threat.radius + 30);
                                x = threat.x + avoidX;
                                y = threat.y + avoidY;
                            }
                        });
                    }
                    
                    waypoints.push({ x, y });
                }
                
                // Calculate metrics
                const distance = this.calculateRouteDistance(waypoints);
                const threatExposure = this.calculateThreatExposure(waypoints);
                const score = this.calculateRouteScore(distance, threatExposure, strategy);
                
                return {
                    waypoints,
                    metrics: {
                        distance: distance.toFixed(1),
                        threatExposure: threatExposure.toFixed(1),
                        score: score.toFixed(0)
                    }
                };
            }
            
            calculateRouteDistance(waypoints) {
                let distance = 0;
                let prev = this.convoy;
                waypoints.forEach(wp => {
                    distance += Math.sqrt((wp.x - prev.x)**2 + (wp.y - prev.y)**2);
                    prev = wp;
                });
                return distance * 0.01; // Convert to km
            }
            
            calculateThreatExposure(waypoints) {
                let exposure = 0;
                waypoints.forEach(wp => {
                    this.syntheticThreats.forEach(threat => {
                        const distance = Math.sqrt((wp.x - threat.x)**2 + (wp.y - threat.y)**2);
                        if (distance < threat.radius * 1.5) {
                            exposure += (threat.radius * 1.5 - distance) / threat.radius;
                        }
                    });
                });
                return exposure;
            }
            
            calculateRouteScore(distance, threatExposure, strategy) {
                if (strategy === 'fastest') {
                    return 100 - distance * 3 - threatExposure * 1;
                } else if (strategy === 'safest') {
                    return 100 - threatExposure * 8 - distance * 0.5;
                } else {
                    return 100 - distance * 2 - threatExposure * 3;
                }
            }
            
            drawAllRoutes() {
                // Clear existing paths
                document.querySelectorAll('.path-optimal, .path-fastest, .path-safest').forEach(el => el.remove());
                
                Object.keys(this.routes).forEach(strategy => {
                    this.drawRoute(strategy, this.routes[strategy].waypoints);
                });
            }
            
            drawRoute(strategy, waypoints) {
                const map = document.getElementById('map');
                let prevPoint = this.convoy;
                
                waypoints.forEach(wp => {
                    const line = document.createElement('div');
                    line.className = `path-${strategy}`;
                    
                    const dx = wp.x - prevPoint.x;
                    const dy = wp.y - prevPoint.y;
                    const length = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    
                    line.style.left = prevPoint.x + 'px';
                    line.style.top = prevPoint.y + 'px';
                    line.style.width = length + 'px';
                    line.style.transform = `rotate(${angle}deg)`;
                    
                    map.appendChild(line);
                    prevPoint = wp;
                });
            }
            
            updateRouteMetrics() {
                Object.keys(this.routes).forEach(strategy => {
                    const metrics = this.routes[strategy].metrics;
                    document.getElementById(`${strategy}-distance`).textContent = `${metrics.distance}km`;
                    document.getElementById(`${strategy}-risk`).textContent = metrics.threatExposure;
                    document.getElementById(`${strategy}-score`).textContent = metrics.score;
                });
            }
            
            updateActiveRoute() {
                // Highlight selected route
                document.querySelectorAll('.path-optimal, .path-fastest, .path-safest').forEach(el => {
                    el.style.opacity = '0.3';
                });
                
                document.querySelectorAll(`.path-${this.selectedRoute}`).forEach(el => {
                    el.style.opacity = '1';
                    el.style.zIndex = '5';
                });
            }
            
            analyzeRoutes() {
                const routes = this.routes;
                let analysis = '';
                let recommendation = '';
                
                // Find best route by category
                const fastest = Object.keys(routes).reduce((a, b) => 
                    parseFloat(routes[a].metrics.distance) < parseFloat(routes[b].metrics.distance) ? a : b);
                const safest = Object.keys(routes).reduce((a, b) => 
                    parseFloat(routes[a].metrics.threatExposure) < parseFloat(routes[b].metrics.threatExposure) ? a : b);
                const highest_score = Object.keys(routes).reduce((a, b) => 
                    parseFloat(routes[a].metrics.score) > parseFloat(routes[b].metrics.score) ? a : b);
                
                analysis = `Fastest: ${fastest} | Safest: ${safest} | Best Score: ${highest_score}`;               // Generate recommendation\n                const threatCount = this.detectedThreats.size;\n                if (threatCount === 0) {\n                    recommendation = 'Low threat environment - Fastest route recommended';\n                } else if (threatCount >= 3) {\n                    recommendation = 'High threat environment - Safest route recommended';\n                } else {\n                    recommendation = 'Moderate threats - Optimal route recommended';\n                }\n                \n                document.getElementById('path-analysis').textContent = analysis;\n                document.getElementById('route-recommendation').textContent = recommendation;\n            }\n            \n            updateThreatMovement() {\n                this.syntheticThreats.forEach((threat, i) => {\n                    const pattern = this.threatMovementPatterns.get(i);\n                    \n                    switch (threat.behavior) {\n                        case 'intercept':\n                            const convoyFutureX = this.convoy.x + 50;\n                            const convoyFutureY = this.convoy.y - 25;\n                            const dx = convoyFutureX - threat.x;\n                            const dy = convoyFutureY - threat.y;\n                            const distance = Math.sqrt(dx*dx + dy*dy);\n                            \n                            if (distance > 30) {\n                                threat.vx = (dx / distance) * threat.speed;\n                                threat.vy = (dy / distance) * threat.speed;\n                            }\n                            threat.x += threat.vx;\n                            threat.y += threat.vy;\n                            break;\n                            \n                        case 'drift':\n                            threat.x += threat.vx;\n                            threat.y += threat.vy;\n                            if (threat.x < 50 || threat.x > 750) threat.vx *= -1;\n                            if (threat.y < 50 || threat.y > 450) threat.vy *= -1;\n                            break;\n                            \n                        case 'patrol':\n                            pattern.patrolTime += 0.1;\n                            threat.x = pattern.originalX + Math.sin(pattern.patrolTime) * 60;\n                            threat.y = pattern.originalY + Math.sin(pattern.patrolTime * 2) * 30;\n                            break;\n                            \n                        case 'expand':\n                            threat.radius = Math.min(120, threat.radius + 0.1);\n                            threat.x += threat.vx;\n                            threat.y += threat.vy;\n                            break;\n                    }\n                    \n                    if (this.detectedThreats.has(i)) {\n                        this.updateThreatVisualPosition(threat, i);\n                    }\n                });\n                \n                // Recalculate routes if threats moved significantly\n                if (this.step % 10 === 0 && !this.calculationInProgress) {\n                    this.recalculateRoutes();\n                }\n            }\n            \n            updateThreatVisualPosition(threat, index) {\n                const threatEl = document.getElementById(`synthetic-threat-${index}`);\n                const zoneEl = document.getElementById(`threat-zone-${index}`);\n                \n                if (threatEl && zoneEl) {\n                    threatEl.style.left = threat.x + 'px';\n                    threatEl.style.top = threat.y + 'px';\n                    \n                    zoneEl.style.left = (threat.x - threat.radius) + 'px';\n                    zoneEl.style.top = (threat.y - threat.radius) + 'px';\n                    zoneEl.style.width = (threat.radius * 2) + 'px';\n                    zoneEl.style.height = (threat.radius * 2) + 'px';\n                }\n            }\n            \n            detectNearbyThreats() {\n                let threatsDetected = false;\n                \n                this.syntheticThreats.forEach((threat, i) => {\n                    const distance = Math.sqrt((this.convoy.x - threat.x)**2 + (this.convoy.y - threat.y)**2);\n                    \n                    if (distance < threat.radius * 1.3) {\n                        if (!this.detectedThreats.has(i)) {\n                            this.logMessage(`üö® Threat detected: ${threat.name}`);\n                            threatsDetected = true;\n                        }\n                        document.getElementById(`synthetic-threat-${i}`).style.display = 'block';\n                        document.getElementById(`threat-zone-${i}`).style.display = 'block';\n                        this.detectedThreats.add(i);\n                        this.updateThreatVisualPosition(threat, i);\n                    } else if (distance > threat.radius * 2) {\n                        document.getElementById(`synthetic-threat-${i}`).style.display = 'none';\n                        document.getElementById(`threat-zone-${i}`).style.display = 'none';\n                        this.detectedThreats.delete(i);\n                    }\n                });\n                \n                if (threatsDetected) {\n                    document.getElementById('threat-consideration').textContent = \n                        `Threat assessment: ${this.detectedThreats.size} active threats`;\n                }\n                \n                this.updateThreatPanel();\n            }\n            \n            updateThreatPanel() {\n                const panel = document.getElementById('threat-panel');\n                panel.innerHTML = '';\n                \n                if (this.detectedThreats.size === 0) {\n                    panel.innerHTML = '<div class=\"status-item safe-status\">No threats in detection range</div>';\n                } else {\n                    this.detectedThreats.forEach(threatIndex => {\n                        const threat = this.syntheticThreats[threatIndex];\n                        const distance = Math.sqrt((this.convoy.x - threat.x)**2 + (this.convoy.y - threat.y)**2);\n                        \n                        const item = document.createElement('div');\n                        item.className = 'status-item threat-alert';\n                        item.innerHTML = `\n                            <strong>${threat.name}</strong><br>\n                            Distance: ${Math.floor(distance * 10)}m | Behavior: ${threat.behavior}\n                        `;\n                        panel.appendChild(item);\n                    });\n                }\n            }\n            \n            moveConvoy() {\n                if (!this.routes[this.selectedRoute]) return;\n                \n                const waypoints = this.routes[this.selectedRoute].waypoints;\n                if (waypoints.length === 0) return;\n                \n                const target = waypoints[0];\n                const dx = target.x - this.convoy.x;\n                const dy = target.y - this.convoy.y;\n                const distance = Math.sqrt(dx*dx + dy*dy);\n                \n                if (distance < 15) {\n                    waypoints.shift();\n                    if (waypoints.length === 0) {\n                        this.logMessage('üèÅ Destination reached!');\n                        this.stopDemo();\n                        return;\n                    }\n                } else {\n                    const speed = 3 * this.speed;\n                    this.convoy.x += (dx / distance) * speed;\n                    this.convoy.y += (dy / distance) * speed;\n                }\n                \n                document.getElementById('convoy').style.left = this.convoy.x + 'px';\n                document.getElementById('convoy').style.top = this.convoy.y + 'px';\n                \n                this.updateMetrics();\n            }\n            \n            updateMetrics() {\n                const distToDest = Math.sqrt((this.destination.x - this.convoy.x)**2 + (this.destination.y - this.convoy.y)**2) * 0.01;\n                \n                document.getElementById('position').textContent = \n                    `${(this.convoy.lat + Math.random() * 0.001).toFixed(4)}, ${(this.convoy.lon + Math.random() * 0.001).toFixed(4)}`;\n                document.getElementById('distance').textContent = `${distToDest.toFixed(1)} km`;\n                document.getElementById('eta').textContent = `${Math.floor(distToDest * 2)} min`;\n                \n                document.getElementById('scenario-desc').textContent = \n                    `Following ${this.selectedRoute} route | ${this.detectedThreats.size} threats active`;\n            }\n            \n            logMessage(message) {\n                const log = document.getElementById('mission-log');\n                const time = new Date().toLocaleTimeString().slice(0, 5);\n                const div = document.createElement('div');\n                div.textContent = `[${time}] ${message}`;\n                log.insertBefore(div, log.firstChild);\n                \n                while (log.children.length > 8) {\n                    log.removeChild(log.lastChild);\n                }\n            }\n            \n            start() {\n                if (this.running) return;\n                this.running = true;\n                this.logMessage('üö¢ Multi-route demo started');\n                this.animate();\n            }\n            \n            pause() {\n                this.running = false;\n                this.logMessage('‚è∏Ô∏è Demo paused');\n            }\n            \n            stop() {\n                this.running = false;\n                this.logMessage('‚èπÔ∏è Demo stopped');\n            }\n            \n            reset() {\n                this.running = false;\n                this.step = 0;\n                this.convoy = { x: 100, y: 400, lat: 25.7617, lon: -80.1918 };\n                this.detectedThreats.clear();\n                this.threatMovementPatterns.clear();\n                \n                this.syntheticThreats = [\n                    { x: 300, y: 450, vx: -1, vy: -2, type: 'small_fast_craft', radius: 60, name: 'Pirate Skiff', speed: 2.5, behavior: 'intercept' },\n                    { x: 500, y: 150, vx: 0, vy: 1, type: 'floating_mine_like_object', radius: 40, name: 'Drifting Mine', speed: 0.8, behavior: 'drift' },\n                    { x: 650, y: 350, vx: -1.5, vy: 0.5, type: 'submarine_periscope', radius: 80, name: 'Sub Contact', speed: 1.2, behavior: 'patrol' },\n                    { x: 150, y: 100, vx: 2, vy: 1, type: 'debris_field', radius: 90, name: 'Debris Field', speed: 0.5, behavior: 'expand' }\n                ];\n                \n                document.querySelectorAll('.threat, .threat-zone, .path-optimal, .path-fastest, .path-safest').forEach(el => {\n                    if (!el.innerHTML.includes('üéØ')) el.remove();\n                });\n                \n                document.getElementById('convoy').style.left = this.convoy.x + 'px';\n                document.getElementById('convoy').style.top = this.convoy.y + 'px';\n                \n                this.drawSyntheticThreats();\n                this.calculateMultipleRoutes();\n                this.updateThreatPanel();\n                this.logMessage('üîÑ Demo reset - Recalculating routes');\n            }\n            \n            recalculateRoutes() {\n                this.logMessage('üß† Recalculating routes due to threat movement');\n                this.calculateMultipleRoutes();\n            }\n            \n            animate() {\n                if (!this.running) return;\n                \n                this.step++;\n                this.updateThreatMovement();\n                this.detectNearbyThreats();\n                this.moveConvoy();\n                \n                setTimeout(() => this.animate(), 1000 / this.speed);\n            }\n        }\n        \n        let dashboard;\n        \n        function startDemo() { dashboard.start(); }\n        function pauseDemo() { dashboard.pause(); }\n        function stopDemo() { dashboard.stop(); }\n        function resetDemo() { dashboard.reset(); }\n        function recalculateRoutes() { dashboard.recalculateRoutes(); }\n        \n        window.onload = () => {\n            dashboard = new MultiRouteMaritimeDashboard();\n        };\n    </script>\n</body>\n</html>"}, {"oldStr": "                analysis = `Fastest: ${fastest} | Safest: ${safest} | Best Score: ${highest_score}`;", "newStr": "                analysis = `Fastest: ${fastest} | Safest: ${safest} | Best Score: ${highest_score}`;"}, {"oldStr": "                \n                // Generate recommendation\n                const threatCount = this.detectedThreats.size;\n                if (threatCount === 0) {\n                    recommendation = 'Low threat environment - Fastest route recommended';\n                } else if (threatCount >= 3) {\n                    recommendation = 'High threat environment - Safest route recommended';\n                } else {\n                    recommendation = 'Moderate threats - Optimal route recommended';\n                }", "newStr": "                \n                // Generate recommendation\n                const threatCount = this.detectedThreats.size;\n                if (threatCount === 0) {\n                    recommendation = 'Low threat environment - Fastest route recommended';\n                } else if (threatCount >= 3) {\n                    recommendation = 'High threat environment - Safest route recommended';\n                } else {\n                    recommendation = 'Moderate threats - Optimal route recommended';\n                }"}]